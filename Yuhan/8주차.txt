
===========================================================================

8주차
01. 리눅스 파일 시스템의 종류
02. 리눅스 파일 시스템의 구조
03. 파일 시스템 마운트
04. 디스크 추가 설치

===========================================================================

< 전주차 복습 >
프로세스란 ? 
- 현재실행중인 프로그램

프로세스의 종류는 5가지
1. 데몬프로세스 : 리눅스 커널에 의해 자동으로 실행
2. 부모프로세스 
3. 자식프로세스
4. 고아프로세스
5. 고아프로세스

프로세스 관리하는 명령 
1. ps : 목록을봄
2. kill : 프로세스 종료 
3. top : 프로세스 관리 도구

프로세스 작업제어하는 명령
1. 포그라운드 : 명령프롬프트가 뜨기전까지 기달림
2. 백그라운드 : 곧바로 다른작업이 가능 -> 실행시간이 많이 걸리는 것을 처리하기에 유리


프로세스 작업 예약
1. at : 한번 실행
2. crontab : 정해진 시간에 반복실행 -> -e 파일생성 
				       -l 파일확인
				       -r 파일삭제




00. 개요	: 7장 내용의 구성

   파일
 시스템의 	-> 	파일시스템의 종류	-> 파일시스템의 구조	-> inode의 구조
종류와 구조
     |
파일 시스템
  마운트	-> 	마운트 포인트		-> mount, umount 명령	-> CD-ROM, USB 메모리 마운트
     |
  디스크 
   관리		-> 	디스크 추가 설치	-> LVM 생성 및 사용	-> 디스크 사용량 확인	-> 파일 시스템 복구








01. 리눅스 파일 시스템의 종류

< 파일시스템 >
- 파일과 디렉터리의 집합을 구조적으로 관리하는 체계
- 어떤 구조를 구성하여 파일이나 디렉터리를 관리하느냐에 따라 다양한 형식의 파일 시스템이 존재


< 리눅스 고유의 디스크 기반 파일 시스템 >
ext(ext1)
- Extended File System의 약자로 1992년 4월 리눅스 0.96c에 포함되어 발표
- 파일 시스템의 최대 크기는 2GB, 파일 이름의 길이는 255바이트까지 지원
- inode 수정과 데이터의 수정 시간 지원이 안되고, 파일 시스템이 복잡해지고 파편화되는 문제
* 파편화 : 디스크들이 분산되어 있다는 말
- 현재 리눅스에서는 ext 파일 시스템을 사용하지 않음

ext2
- ext 파일 시스템이 가지고 있던 문제를 해결하고, 1993년 1월 발표
- ext2는 ext3 파일 시스템이 도입되기 전까지 사실상 리눅스의 표준 파일 시스템으로 사용
- 이론적으로 32TB까지 가능

ext3
- ext3는 ext2를 기반으로 개발되어 호환이 가능하며 2001년 11월 공개
- ext3의 가장 큰 장점은 저널링 기능을 도입 복구기능 강화
* 저널링 : 파일의 손상을 복구할 수 있는 파일 시스템
- 파일 시스템의 최대 크기는 블록의 크기에 따라 2~32TB까지 지원

ext4
- ext4 파일 시스템은 1EB(엑사바이트, 1EB = 1,024 * 1,024TB) 이상의 볼륨과 16TB 이상의 파일을 지원
- ext2 및 ext3와 호환성을 유지하며 2008년 12월 발표


< 리눅스에서 지원하는 다른 디스크 기반 파일 시스템 >
msdos	: MS-DOS 파티션을 사용하기 위한 파일 시스템
iso9660	: CD-ROM, DVD의 표준 파일 시스템으로 읽기 전용으로 사용
nfs	: network file system으로 원격 서버의 디스크를 연결할 때 사용
ufs 	: Unix file system으로 유닉스의 표준 파일 시스템
vfat	: 윈도 95, 98, NT를 지원하기 위한 파일 시스템
hpfs	: HPFS를 지원하기 위한 파일 시스템
ntfs	: 윈도의 NTFS를 지원하기 위한 파일 시스템
sysv	: 유닉스 시스템V를 지원하기 위한 파일 시스템
hfs	: 맥 컴퓨터의 hfs 파일 시스템을 지원하기 위한 파일 시스템


< 특수 용도의 가상 파일 시스템 >	: 디스크가 아닌 메모리에 생성	
swap 
- 스왑 영역을 관리하기 위한 스왑 파일 시스템

tmpfs
- temporay file system으로 메모리에 임시 파일을 저장하기 위한 파일 시스템이며,
  시스템이 재시작할 때마다 기존 내용이 없어진다.
- /tmp 디렉터리를 예로 들 수 있다 (페도라 18부터 )

proc
- proc 파일 시스템으로 /proc 디렉터리
- 커널의 현재 상태를 나타내는 파일을 가지고 있다.

ramfs 
- 램디스크를 지원하는 파일 시스템

rootfs
- root file system으로 / 디렉터리
- 시스템 초기화 및 관리에 필요한 내용을 관리


< 현재 시스템이 지원하는 파일 시스템 확인하기 >
/proc/filesystems는 현재 커널이 지원하는 파일 시스템의 종류를 알려줌








02. 리눅스 파일 시스템의 구조

< 리눅스의 모든 파일 시스템의 기본 개념 >
- 파일은 inode로 관리된다.
- 디렉터리는 단순히 파일의 목록을 가지고 있는 파일일 뿐이다.
- 특수 파일을 통해 장치에 접근할 수 있다.

< ext4 파일 시스템의 구조 >
- 효율적으로 디스크를 사용하기 위해 저장 장치를 논리적인 블록의 집합(블록 그룹)으로 구분
- 일반적으로 블록은 4KB이고 실제 크기는 시스템의 설정에 따라 변경 가능
* 블록 그룹 유형
	-> 블록 그룹 0 : 파일 시스템의 첫 번째 블록 그룹으로 특별하게 그룹 0 패딩과 슈퍼블록,
 			 그룹 디스크립터를 가지고 있다.
	-> 블록 그룹 a : 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩이 없으나 
			 슈퍼블록과 그룹 디스크립터에 대한 복사본을 가지고 있다.
	-> 블록 그룹 b : 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩, 
			 슈퍼블록, 그룹 디스크립터가 없고 바로 데이터 블록 비트맵으로 시작한다.

그룹 0 패딩
- 블록 그룹 0의 첫 1,024 바이트는 특별한 용도로 사용되는데, x84 부트 섹터와 부가 정보를 저장

슈퍼블록
- 파일 시스템과 관련된 다양한 정보가 저장
	-> 전체 inode의 개수			
	-> 할당되지 않은 블록의 개수
	-> 첫 번째 데이터 블록의 주소
	-> 그룹당 블록의 개수
	-> 파일 시스템의 생태
	* 전체 블록의 개수
	* 할당되지 않은 inode의 개수
	* 블록의 크기
	* 마운트 시간
	* 그룹 디스크립터의 크기
- 슈퍼블록에 문제가 생길 경우 전체 파일 시스템을 사용할 수 없게 됨
- 슈퍼블록을 다른 블록 그룹에 복사하고, 
  블록 그룹 0의 슈퍼블록을 읽을 수 없을 경우 복사본을 사용하여 복구

그룹 디스크럽터와 GDT 예약 블록
- 그룹 디스크럽터도 블록 그룹 0에 있는 것으로 슈퍼블록의 다음에 위치
- 그룹 디스크럽터에 저장되는 정보
	-> 블록 비트맵의 주소
	-> inode 테이블의 주소
	-> 할당되지 않은 inode의 개수
	-> 블록 비트맵, inode 비트맵 체크섬
	* inode 비트맵의 주소
	* 할당되지 않은 블록의 개수
	* 디렉터리의 개수


데이터 블록 비트맵과 inode 비트맵
- 데이터 블록 비트맵은 블록 그룹에 포함된 데이터 블록의 사용 여부를 확인하는데 사용
- inode 비트맵은 inode 테이블의 항복이 사용중인지를 표시

inode 테이블과 데이터 블록
- inode에는 파일 정보를 저장하고 데이터 블록에는 실제 데이터를 저장


< 파일 시스템과 디렉터리 계층 구조 >
- 디렉터리 계층 구조는 리눅스의 전체 파일과 디렉터리를 어떤 구조로 정리하고 관리할 것인지를 정의한 것
- 실제 파일이 저장되어 있는 파일 시스템은 디렉터리 계층 구조에 연결되어야 사용자가 접근 가능

< 한 파일 시스템으로 구성하기 >
- 디렉터리 계층 구조에서 보이는 모든 디렉터리와 파일을 하나의 파일 시스템으로 구성

< 여러 파일 시스템으로 구성하기 >
- 디렉터리 계층 구조를 여러 파일 시스템으로 구분하여 구성
- 여러 파일 시스템으로 나누어 디렉터리 계층 구조를 구성할 경우,
  일부 파일 시스템에 문제가 생기더라도 다른 파일 시스템의 파일은 안전








03. 파일 시스템 마운트

< 마운트 >
- 파일 시스템을 디렉터리 계층 구조의 특정 디렉터리와 연결하는 것

< 마운트 포인트 >
- 디렉터리 계층 구조에서 파일 시스템이 연결되는 디렉터리를 마운트 포인트

< 파일 시스템 마운트 설정 파일 >
- 리눅스에서 시스템이 부팅될 때 자동으로 파일 시스템이 마운트되게 하려면 /etc/fstab 파일에 설정
- /etc/fstab 파일의 기능 : 파일 시스템의 마운트 설정 정보 저장


< /etc/fstab 파일의 구조 >

장치명	마운트포인트	파일시스템의종류	옵션	덤프관련설정	파일점검옵션

etc/fstab 파일의 예
- 장치명 : /dev/mapper/fedora-root
	-> 파일시스템 장치명, 예를 들어 /dev/hda1, /dev/sda1과 같이 특정 디스크를 지정
- 마운트 포인트 : /
	-> 파일 시스템이 마운트될 마운트 포인트를 설정
- 파일 시스템의 종류 : ext4
	-> 파일 시스템의 종류를 설정, ext2, ext3, ext4 외
- 옵션 : defaults
	-> 파일 시스템의 속성을 지정
- 덤프 관련 설정 : 1
	-> 0(dump 불가)
	-> 1(dump 가능)
- 파일 점검 옵션 : 1
	-> 0 : 부팅시 fsck 안함
	-> 1 : 루트 파일시스템
	-> 2 : 루트 파일시스템 이외

두 번째 항목의 UUID는 'universally unique identifier'의 약자로 로컬 시스템과 
다른 시스템에서 파일 시스템을 유일하게 구분해주는 128비트의 숫자
- UUID는 시스템의 하드웨어 정보와 시간 정보를 조합하여 랜덤으로 생성
- UUID로 지정된 장치는 /dev/disk/by-uuid 디렉터리에서 찾을 수 있음

< 파일 시스템 속성 설정 옵션 >
defaults : 일반적인 파일 시스템에 지정하는 속성 rw, nouser, auto, exec, suid 속성을 모두 포함
auto : 부팅시 자동으로 마운트
exec : 실행 파일이 실행되는 것을 허용
suid : setuid, setgid의 사용을 허용
ro : 읽기 전용 파일 시스템
rw : 읽기, 쓰기가 가능한 파일 시스템
user : 일반 사용자도 마운트가 가능
nouser : 일반 사용자의 마운트가 불가능, root만 마운트
noauto : 부팅 시 자동으로 마운트하지 않음
noexec : 실행 파일이 실행되는 것을 허용하지 않음
nosuid : setuid, setgid의 사용을 금지
usrquota : 사용자별로 디스크 쿼터 설정이 가능
grpquota : 그룹별로 디스크 쿼터 설정이 가능



< 마운트 관련 명령 >
mount : 파일 시스템을 마운트 
	mount [옵션][장치명 또는 마운트 포인트]
	-t 파일 시스템 종류 : 파일 시스템 종류를 지정
	-o 마운트 옵션 : 마운트 옵션을 지정
	-f : 마운트할 수 있는지 점검
	-r : 읽기만 가능하게 마운트 (-o ro와 동일)
* mount 명령만 사용하는 경우
- 옵션이나 인자를 지정하지 않고 mount 명령을 사용하면 현재 마운트 되어 있는 정보를 출력
* mount 명령으로 출력되는 정보는 /etc/mtab 파일의 내용과 동일
- 장치명
- 마운트 포인트
- 파일 시스템의 종류
- 마운트 옵션
- 사용하지 않는 항목 두개(0,0)
* mount 명령으로 장치를 연결하는 방법
- 하드디스크를 디렉터리 계층 구조에 연결할 때 
  mount /dev/sdb1  /mnt


umount : 파일 시스템을 언마운트
	umount [옵션][장치명 또는 마운트 포인트]
	-t 파일 시스템 종류 : 파일 시스템 종류를 지정
	








04. 디스크 추가 설치

< 디스크 추가 단계 >
새 디스크 장착 	->	디스크 파티션 나누기	->	파티션에 파일시스템 생성(포맷)	->	디스크 마운트


< 가상 머신에 디스크 추가하기 >
< 디스크 파티션 나누기 >
- 파티션이란 하나의 디스크를 독립된 영역으로 구분하는 것
- 디스크 전체를 하나의 파티션으로 사용할 수도 있고 여러 개의 파티션으로 나누어 사용할 수도 있음

< 디스크 장치의 이름 >
- 리눅스에서 IDE 컨트롤러에 연결된 디스크는 /dev/hd로 시작
- SCSI나 SATA 컨트롤러에 장착된 디스크는 /dev/sd로 시작하는 이름을 주로 사용
- 최근에는 IDE, SCSI 등 구분없이 모두 /dev/sd로 시작하는 이름을 사용
- 컨트롤러에 연결되는 디스크의 순서에 따라 다음과 같이 알파벳이 추가 : /dev/sda, /dev/sdb

< 디스크 장치의 이름과 파티션 표시하기 >
- 하나의 디스크를 여러 개의 파티션으로 구분할 경우 파티션은 디스크 장치 이름의 뒤에 숫자를 붙여서 표시
	-> /dev/sda 	: 첫째 디스크 전체를 의미하는 장치 이름
	-> /dev/sda0 	: 디스크의 첫째 파티션
	-> /dev/sda1 	: 디스크의 둘째 파티션
 



< fdisk 명령 >
디스크의 파티션 생성, 삭제, 보기 등 파티션을 관리
fdisk [옵션][장치명]
* 옵션 
	-> -b 크기 : 섹터 크기를 지정 ( 512, 1024, 2048, 4096 )
	-> -l : 파티션 테이블을 출력
* 내부명령
	-> a : 부팅 파티션 설정
	-> t : 파티션의 시스템 ID를 변경
 	-> w : 파티션 정보를 디스크에 저장하고 종료
	-> m : 도움말을 출력
	-> d : 파티션 삭제
	-> n : 파티션 추가
	-> p : 파티션 출력


< 파일 시스템 생성하기 >
- 파일 시스템은 이 파티션에서 파일과 디렉터리를 관리하기 위한 구조를 만드는 것

< 파일 시스템 생성 명령 > : mkfs, mke2fs 
mkfs 
- 리눅스 파일 시스템을 만듬
- mkfs [옵션][장치명]
- -t 종류 : 파일 시스템의 종류를 지정 (기본값은 ext2)

mke2fs
- 리눅스 개정판 확장 파일 시스템 (ext2, ext3, ext4)을 만듬
- mke2fs [옵션][장치명]
- -t 종류 : 파일 시스템의 종류를 지정 (기본값은 ext2)
- -b 블록 크기 : 블록 크기를 바이트 수로 지정
- -c : 배드 블록을 체크
- -f 프래그먼트 크기 : 프래그먼트 크기를 바이트 수로 지정
- -i inode당 바이트 수 : inode당 바이트 수를 지정 (기본값은 4,096B)
- -m 예약 블록 퍼센트 : 슈퍼유저에게 예약해둘 블록의 퍼센트를 지정 (기본값은 5%)



< mkfs 명령으로 파일 시스템 생성하기 > :/dev/sdb1 파티션에 ext2 파일 시스템 생성

< mkfs.ext3 명령으로 /dev/sdb2 파티션에 ext3 파일 시스템을 생성 >
		     장치명

< mke2fs 명령으로 /dev/sdc2 파티션에 ext4 파일 시스템 생성 > 



< 디스크 마운트 >
- 파일 시스템을 디렉터리 계층 구조에 마운트 

< 마운트 포인트 준비하기 >
- mkdir /mnt/hdd1
- mkdir /mnt/hdd2
- mkdir /mnt/hdd3

< 파일 시스템 마운트하기 >
- /dev/sdb1을 /mnt/hdd1 디렉터리에 마운트
	-> mount /dev/sdb1 /mnt/hdd1

- /dev/sdb2 파티션을 /mnt/hdd2 디렉터리에 마운트
	-> mount -t ext3 /dev/sdb2 /mnt/hdd2


< 파일 시스템 사용하기 >
cp /etc/hosts /mnt/hdd1		=> /etc/hosts을 /mnt/hdd1에다가 복사하겠다는말 
ls /hdd1
hosts lost+found		=> 파일이 복사된걸 확인할 수 있음

< 이 상태에서 마운트를 해제하면 >
umount /mnt/hdd1		=> 해제하고 하는 장치이름이나 마운트포인트
ls /mnt/hdd1		
				=> 해제되어서 밑에 아무것도 뜨지 않음

- 마운트가 해제된 뒤 /mnt/hdd1 디렉터리에 아무 파일도 없음
- 파일 시스템의 마운트가 해제되면 이 파티션과의 연결이 끊어지므로 
  /mnt/hdd1에서 hosts 파일을 볼 수 없음



< 여러 디스크를 하나처럼 사용하기 >
- 디스크의 용량이 부족할 때 여러 개의 디스크를 하나의 디스크처럼 사용

< LVM의 기본 개념 >
- LVM은 독립적으로 구성된 디스크 파티션을 하나로 연결하여 한 파티션처럼 사용할 수 있도록 해줌
- LVM 관련 용어
	-> PV(physical volume, 물리볼륨) : /dev/sdb1, /dev/sdb2 같은 실제 하드디스크의 파티션을 의미
	-> VG(volume group, 볼륨그룹) : 여러 개의 PV를 그룹으로 묶은 것을 뜻함. 
      					예를 들어 /dev/sdb1, /dev/sdb2가 GRP1이라는 그룹을 만들 때 GRP1을 VG라고 함
	-> LV(logical volume, 논리볼륨) : VG를 다시 적절한 크기의 파티션으로 나눌 때 각 파티션을 LV라고 함
	-> PE(physical extent) : PV가 가진 일정한 블록을 의미
	-> LE(logical extent) : LV가 가진 일정한 블록을 의미

	PV 	->	VG	-> 	LV	-> 	파일 시스템 생성. 마운트
