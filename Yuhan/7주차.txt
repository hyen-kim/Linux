
===========================================================================

7주차

===========================================================================


프로세스관리 	프로세스의개념 -> 프로세스검색 -> 프로세스종료 -> 프로세스관리도구

     | 
      
  작업제어	포그라운드작업 -> 백그라운드작업 -> 작업제어

     |
    
  작업예약	한 번실행 -> 반복실행



01. 프로세스의 개념
- 프로세스 : 현재 시스템에서 실행 중인 프로그램
- 프로세스의 부모-자식 관계
	-> 프로세스는 부모-자식 관계를 가지고 있음
	-> 필요에 따라 부모 프로세스는 자식 프로세스를 생성,
           자식 프로세스는 또 다른 자식 프로세스 생성 가능
	-> 부팅할 때 스케줄러가 실행한 프로세스인 systemd와 kthreadd 프로세스를 
           제외하면 모든 프로세스는 부모 프로세스를 가지고 있음
	-> 자식 프로세스는 할 일이 끝나면 부모 프로세스에 결과를 돌려주고 종료


	부모 프로세스 ------------------>  자식프로세스
			   생성
                      <------------------
                           종료 및 복귀

* 프로세스의 번호
	-> 각 프로세스는 고유한 번호를 가지고 있는데 이것이 PID


* 프로세스의 종류
- 데몬 프로세스	: 백그라운드에서 실행
	-> 특정 서비스를 제공하기 위해 존재하며 리눅스 커널에 의해 실행
	-> 평소에는 대기상태로 있다가 필요하다면 바로 접속가능

- 고아 프로세스
	-> 자식 프로세스가 아직 실행 중인데 부모 프로세스가 먼저 종료된 자식 프로세스는 고아 프로세스
	-> 1번 프로세스가 고아 프로세스의 새로운 부모 프로세스가 되어 고아 프로세스의 작업 종료 지원 

- 좀비 프로세스	: kill이라는 명령을 통해서 제거 불가
	-> 자식 프로세스가 실행을 종료했는데도 프로세스 테이블 목록에 남아 있는 경우
	-> 좀비 프로세스는 프로세스 목록에 defunct 프로세스라고 나오기도 함
	-> 좀비 프로세스가 증가하면 프로세스 테이블의 용량이 부족해서 일반 프로세스가 실행되지 않을 수도 있음






02. 프로세스 관리 명령
- 현재 실행 중인 프로세스의 목록을 보는 명령 : ps
	-> 유닉스옵션 : 묶어서 사용할 수 있고, 붙임표로 시작한다.
	-e : 모든 프로세스의 정보를 출력
	-f : 프로세스의 자세한 정보 출력
	-u : uid 특정 사용자에 대한 모든 프로세스의 정보 출력
	-p : pid로 지정한 특정 프로세스의 정보 출력

	-> BSD 옵션 : 묶어서 사용할 수 있고, 붙임표로 시작하지 않는다.
	a : 터미널에서 실행한 프로세스의 정보 출력
	* R : 실행중
	  S : 인터럽트가 가능한 대기 상태
	  T : 정지된 상태
	  Z : 좀비 프로세스
   	  STIME : 프로세스의 시작 날짜나 시간
	  s : 세션 리더 프로세스
          + : 포그라운드 프로세스 그룹
          I(소문자 L) : 멀티스레드
	u : 프로세스의 소유자 이름, cpu 사용량, 메모리 사용량 등 상세정보 출력
	x : 시스템에서 실행 중인 모든 프로세스의 정보를 출력

	-> GNU 옵션 : 붙임표 두 개로 시작한다.
	--pid : 목록으로 지정한 특정 PID의 정보를 출력
	
	* 터미널에서 실행한 프로세스의 상세 정보 출력하기 : a옵션과 u옵션
	* 전체 프로세스 목력 출력하기 (유닉스 옵션) : -e옵션
		-> 실행중인 모든 프로세스를 출력
		-> TTY 값이 ?인 것은 대부분 데몬으로 시스템이 실행한 프로세스
	* 전체 프로세스의 더 자세한 정보 출력 : -ef옵션
	* 전체 프로세스 목록 출력하기 (BSD 옵션) : ax옵션
	* aux 옵션은 -ef처럼 시스템에서 실행 중인 모든 프로세스에 대한 자세한 정보를 출력
	* 특정 사용자의 프로세스 목록 출력하기 : -u옵션
	* ps 명령을 이용해 특정 프로세스 정보 검색하기 
		-> ps 명령과 grep 명령을 |로 연결하여 특정 프로세스에 대한 정보를 검색
	
- pgrep 명령을 이용해 특정 프로세스 정보 검색하기
	-x : 패턴과 정확히 일치하는 프로세스의 정보를 추렭
	-n : 패턴을 포함하고 있는 가장 최근 프로세스의 정보 출력
	-u 사용자명 : 특정 사용자에 대한 모든 프로세스를 출력	-> ( 사용자명을 지정하여 검색 )
	-l : PID와 프로세스 이름을 출력	-> ( PID와 명령 이름만 출력 )
	-t term : 특정 단말기와 관련된 프로세스의 정보를 출력
	* pgrep 명령을 ps 명령과 연결하여 사용

- 시그널 : 프로세스에 무언가 발생했음을 알리는 메시지
 	- 리눅스에서 지원하는 시그널 목록 : kill -l 명령으로 알 수 있음
	* 주요 사용하는 시그널
	SIGHUP 	1	종료	터미널과의연결이 끊어졌을 때 발생
	SIGINT	2 	종료	인터럽트로 사용자가 ctrl+c를 입력하면 발생
	SIGOUT	3	종료	종료신호로 사용자가 ctrl+\를 입력하면 발생
	SIGKILL	9	종료	이 시그널을 받은 프로세스는 무시할 수 없으며 강제로 종료
	SIGALRM	14	종료	알람에 의해 발생
	SIGTERM	15	종료	kill 명령이 보내는 기본 시그널


- kill 명령을 이용해 프로세스 종료하기
	- 지정한 시그널을 프로세스에 보낸다.
	- kill [-시그널] PID

- pkill 명령을 이용해 프로세스 종료하기		== killall 과 같은 기능
	- PID가 아니라 프로세스의 명령 이름(CMD)으로 프로세스를 찾아 종료



02-1. 프로세스 관리 도구
- top 명령 : 현재 실행 중인 프로세스에 대한 정보를 주기적으로 출력
	-> 실시간으로 정보를 업데이트 해줌

	* top 명령의 출력 정보
	PID	프로세스 ID	
	USER	사용자 계정
	PIR	우선순위
	NI 	Nice 값
	VRT	프로세스가 사용하는 가상 메모리의 크기
	RES	프로세스가 사용하는 메모리의 크기
	SHR	프로세스가 사용하는 공유 메모리의 크기
	%CPU	퍼센트로 표시한 CPU 사용량
	%MEM	퍼센트로 표시한 메모리 사용량
	TIME+	CPU 누적 이용 시간
	COMMAND	명령 이름

	* top 명령의 내부 명령
	enter, space bar	화면을 즉시 다시 출력
	h, ?			도움말 화면을 출력
	k			프로세스를 종료, 종료할 프로세스의 PID를 물어봄
	n 			출력하는 프로세스의 개수를 바꿈
	p			CPU 사용량에 따라 '정렬'하여 출력
	q 			top 명령을 종료
	M 			사용하는 메모리의 크기에 따라 '정렬'하여 출력
	u			사용자에 따라 '정렬'하여 출력
	








03. 포그라운드, 백그라운드 프로세스와 작업 제어
* 포그라운드 작업 
- 포그라운드 프로세스 : 사용자가 입력한 명령이 실행되어 결과가 출력될 때까지 기다려야하는 포그라운드 방식
- 이를 작업 제어에서는 포그라운드 작업이라고 함
- 보이는 그대로 처리과정을 보여주는 것
ex) sleep 100	-> 포그라운드 작업
   		-> sleep 명령이 끝날 때까지 기다려야함


* 백그라운드 작업
- 백그라운드 프로세스 : 명령을 실행하면 명령의 처리가 끝나는 것과 관계없이 곧바로 프롬프트가 출력되어
			사용자가 다른 작업을 계속 할 수 있음
- 작업제어 에서는 백그라운드 작업이라고 함
ex) sleep 100 &	-> 백그라운드 작업
		-> 프롬프트가 바로 나와 다른 명령을 실행할 수 있음


* 백그라운드 작업과 출력 방향 전환하기
- 백그라운드로 처리할 때는 주로 출력과 오류 방향 전환을 하여 실행 결과와 오류 메시지를 파일로 저장
ex) find / -name passwd > pw.dat 2>&1 & 	-> pw.dat에 결과와 오류를 저장
				 2는 표준오류, 표준출력 결과물에 같이 넣어서 저장해
				 & : 백그라운드로 처리해
* tip) 	> : 표준출력장치



* 작업제어
- 작업 제어는 작업 전환과 작업 일시중지, 작업 종료를 의미
- 작업 전환 : 포그라운드 작업 -> 백그라운드 작업, 백그라운드 작업 -> 포그라운드 작업
- 작업 일시중지 : 작업을 잠시 중단
- 작업 종료 : 프로세스를 종료하는 것처럼 작업을 종료


* 작업 목록 보기 : jobs 
- 백그라운드 작업을 모두 보여준다, 특정 작업 번호를 지정하면 해당 작업의 정보만 보여줌
- jobs %작업번호
	[1] +		
	[1] - 
	작업순서 +, - 
	작업순서가 +이면 작업순서가 +인 정보만 출력
	작업순서가 -이면 작업순서가 -인 정보만 출력

ex) jobs
[1]-	Running 	sleep 100 &
[2]+	Running 	find / -name pwsswd > pw.dat 2>&1

* 위의 jobs 명령의 출력 정보
작업번호	[1] 		작업번호로서 백그라운드로 실행할 때마다 순차적으로 증가 [1, 2, 3 ...]

작업순서	+		작업순서를 표시
				+ : 가장 최근에 접근한 작업
				- : + 작업보다 바로 전에 접근한 작업
				공백 : 그 외의 작업

상태		실행중		작업 상태를 표시
				Running 	: 현재 실행 중
				Done		: 작업이 정상적으로 종료
				Terminated 	: 작업이 비정상적으로 종료
				Stopped 	: 작업이 잠시 중단

명령		sleep 100 &	백그라운드로 실행 중인 명령 



* 작업 전환하기
ctrl + z 또는 stop %작업번호	포그라운드 작업을 중지한다 (종료X, 잠시중단) 
bg %작업번호			작업 번호가 지시하는 작업을 백그라운드 작업으로 전환
fg %작업번호			작업 번호가 지시하는 작업을 포그라운드 작업으로 전환

ex) 작업전환의 예 : 포그라운드 -> 백그라운드
jobs				-> 백그라운드 작업이 없음
sleep 100			-> 포그라운드로 실행
^Z				-> ctrl + z로 일시 중지
[1]+ stopped	sleep 100 	-> 일시 중지된 상태
jobs
[1]+ Running 	sleep 100&	-> 백그라운드로 실행 중


ex) 작업전환 예 : 백그라운드 -> 포그라운드
jobs
[1]+ Running	sleep 100 &
fg				-> 포그라운드로 전환
sleep 100			-> 포그라운드로 실행 중




* 작업 종료하기 : Ctrl + c
- 포그라운드 작업은 Ctrl + c를 입력하면 대부분 종료
sleep 100			-> 포그라운드로 실행 중
^C				-> 강제 종료


- 백그라운드 작업은 kill 명령으로 강제 종료 : PID 또는 %작업 번호
sleep 100&			-> 백그라운드로 실행 중
[1] 89061
kill &1				-> 강제 종료
[1]+ Terminated	sleep 100 	-> 종료 메시지가 출력




* 로그아웃 후에도 백그라운드로 작업 계속 실행하기 : nohup
- 로그아웃한 다음에도 작업이 완료될 때까지 백그라운드 작업을 실행해야할 경우 사용
- 명령 실행 시 다음 예와 같이 출력 방향 전환을 하면 nohup.out 파일을 생성하지 않고
  지정한 파일에 결과와 오류 메시지 출력

nohup : 로그아웃한 후에도 백그라운드 작업을 계속 실행
nohup 명령&

ex) 명령 사용 예
nohup find / -name passwd &
[1] 89868
nohup: ignoring input and appending output to 'nohup.out'
exit


ex) 다시 로그인하여 파일 내용 확인
more nohup.out



04. 작업 예약
- 특정한 시간에 작업을 수행하도록 예약할수 있는 두 가지 방법
	-> 정해진 시간에 한 번만 수행
	-> 정해진 시간에 반복 수행

- 정해진 시간에 한 번 실행 : at [옵션][시간]
	-l : 현재 실행 대기 중인 명령의 전체 목록을 출력 (atq 명령과 동일)
	-r 작업번호 : 현재 실행 대기 중인 명령 중 해당 작업 번호를 삭제 (atrm 과 동일)
	-m : 출력 결과가 없더라도 작업이 완료되면 사용자에게 메일로 알려줌
	-f 파일 : 표준 입력 대신 실행할 명령을 파일로 지정

	* at 명령 설정하기
	- at 명령을 사용하여 정해진 시간에 명령을 실행하도록 예약하려면 at 명령 뒤에 시간을 명시
	at 04:30 pm
	
	* 시간을 지정하는 형식
	at 4pm + 3days 	 : 지금부터 3일 후 오후 4시에 작업을 수행
	at 10am Jul 31 	 : 7월 31일 오전 10시에 작업을 수행
	at 1am tomorrow	 : 내일 오전 1시에 작업 수행
	at 10:00am today : 오늘 오전 10시에 작업을 수행  

	-> at로 실행할 명령은 기본적으로 표준 입력으로 지정 : 명령의 입력을 마치려면 ctrl + d 입력
	-> at는 끝이 언제인지 모르므로 ctrl + d	-> <EOT>

	* at 작업 파일 확인하기
	- at로 생성된 작업 파일은 /var/spool/at 디렉터리에 저장
	- root 사용자만 /var/spool/at 디렉터리 내용 확인 가능

	* at 작업 목록 확인하기 : -l 옵션, atq
	- at 명령으로 설정된 작업의 목록은 -l 옵션으로 확인
	- atq 명령으로도 확인 가능

	* at 작업 삭제하기 : -d 옵션, atrm 
	- at 명령으로 설정한 작업이 실행되기 전에 삭제하려면 -d 옵션을 사용하고
	  삭제할 작업 번호를 지정 
	- atrm 명령은 at -d와 같은 기능 수행
	
	* at 명령 사용 제한하기
	- 관련된 파일 : /etc/at.allow(허락된)와 /etc/at.deny(허락되지않은)
	- /etc/at.allow 파일과 /etc/at.deny 파일에는 한줄에 사용자 이름을 하나씩만 기록
	- /etc/at.allow 파일이 있으면 이 파일에 있는 사용자만 at 명령을 사용할 수 있다.
 	  이 경우에 /etc/at.deny 파일은 무시된다.
	- /etc/at.allow 파일이 없으면 /etc/at.deny 파일에 지정된 사용자를 제외한 
	  모든 사용자가 at 명령을 사용할 수 있다.
	- 만약 두 파일이 모두 없다면 root만 at 명령을 사용할 수 있다.
	- 한 사용자가 두 파일 모두에 속해 있다면 그 사용자는 at 명령을 사용할 수 있다.
	  /etc/at.allow 파일이 적용되기 때문이다.
	- /etc/at.deny를 빈 파일로 두면 모든 사용자가 at 명령을 사용할 수 있는데, 이것이 초기 설정이다.
	- at.deny 파일에 user1 사용자가 기록되어 있다면 at 명령을 실행했을 때 사용 권한이 없다는 메시지가 출력  


- 정해진 시간에 반복 실행 : crontab [-u 사용자 ID] [옵션] [파일명]
	-e : 사용자의 crontab 파일을 편집
	-l : crontab 파일의 목록을 출력
	-r : crontab 파일을 삭제 

	* crontab 파일 형식
	분(0~59)	시(0~23) 	일(1~31)	요일(0~6)	작업내용


	* crontab 파일 생성하고 편집하기 : crontab -e
	- crontab 편집기는 기본적으로 VISUAL 또는 EDITOR 환경 변수에 지정된 편집기를 사용
	- crontab -e 명령으로 편집한 파일을 저장하면 자동적으로 /var/spool/crom 디렉터리에 사용자 이름으로 생성
	
	* crontab 파일 내용 확인하기 : crontab -l

	* crontab 파일 삭제하기	: crontab -r
	crontab -u user1 -r	: user1이 만들어놓은 crontab을 삭제하여라

	* crontab 명령 사용 제한하기
	- /etc/cron.allow, /etc/cron.deny 파일
	- cron.deny 파일은 기본적으로 있지만 cron.allow 파일은 관리자가 만들어야함
	- 두 파일이 적용되는 기준
		-> /etc/cron.allow 파일이 있으면 이 파일 안에 있는 사용자만 crontab 명령을 사용할 수 있다.
		-> /etc/cron.allow 파일이 없고 /etc/cron.deny 파일이 있으면
                   이 파일에 사용자 계정이 없어야 crontab 명령을 사용할 수 있다.
		-> /etc/cron.allow 파일과 /etc/cron.deny 파일이 모두 없다면 
		   시스템 관리자만 crontab 명령을 사용할 수 있다.
	- 두 파일이 모두 없는데 일반 사용자가 crontab 명령을 사용하려고 하면 다음과 같은 메시지 출력
	see crontab(1) for more information


